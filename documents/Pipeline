# Video Search Pipeline Documentation

This document outlines the end-to-end workflow of the Video Search System, detailing how files connect and the purpose of key data artifacts.

## 1. Pipeline Overview

The system transforms raw video data into a searchable mathematical index through the following stages:

**Raw Video** -> **Keyframes** -> **Local Features (SIFT)** -> **Global Descriptors (Fisher Vectors)** -> **Search Index**

### Step-by-Step Flow

1.  **Ingestion & Database (`process_videos.py`, `db_utils.py`)**
    *   **Input**: Videos placed in `static/videos/`.
    *   **Process**: The system tracks videos in the SQLite database (`videosearch.db`). `process_videos.py` scans for unindexed videos.
    *   **Output**: Database records updated.

2.  **Keyframe Extraction (`indexer/keyframes/extract_keyframes.py`)**
    *   **Input**: A video file (e.g., `test_video.mp4`).
    *   **Process**: Uses **FFmpeg** to extract frames at a rate of 1 frame/sec (default).
    *   **Output**: JPEG images stored in `work_dir/keyframes/<video_name>_keyframes/`.

3.  **Feature Extraction (`indexer/local_descriptors/extract_sift.py`)**
    *   **Input**: Keyframe JPEG images.
    *   **Process**: Uses **OpenCV** to detect and compute SIFT (Scale-Invariant Feature Transform) descriptors for each image.
    *   **Output**: NumPy files (`.npy`) stored in `work_dir/features/`.
    *   **Format**: Each `.npy` file corresponds to one frame and contains a dictionary: `{'keypoints': [...], 'descriptors': [...]}`.

4.  **Indexing (`indexer/global_descriptors/index_dataset.py`)**
    *   **Input**:
        *   All `.npy` feature files in `work_dir/features/`.
        *   **GMM Model** (`gmm.pickle`): A pre-trained visual vocabulary.
    *   **Process**:
        *   Loads SIFT descriptors for a frame.
        *   Encodes them into a single high-dimensional **Fisher Vector** using the GMM model.
    *   **Output**: `work_dir/index.npy`.
    *   **Format**: A dictionary mapping `video_frame_id` -> `Fisher Vector array`. This is the actual "searchable memory" of the system.

5.  **Retrieval (`retriever/retrieve.py`)**
    *   **Input**: A user-uploaded query image.
    *   **Process**:
        *   Extracts SIFT features from the query image.
        *   Computes its Fisher Vector using the same `gmm.pickle`.
        *   Calculates **Cosine Similarity** between the query vector and every vector in `index.npy`.
    *   **Output**: A ranked list of matching frames/videos.

---

## 2. Key Folders and File Types

### Data Directories

*   **`static/videos/`**: Storage for raw `.mp4` video files.
*   **`work_dir/`**: The main "workspace" where all processing artifacts are stored.
    *   **`work_dir/keyframes/`**: Contains subfolders of extracted JPEG images.
    *   **`work_dir/features/`**: Contains thousands of `.npy` files (one per frame).

### Important File Extensions & Artifacts

*   **`videosearch.db` (SQLite Database)**
    *   **Purpose**: Relational database stores metadata.
    *   **Content**: Tables for videos (paths, indexed status, upload time). It acts as the "registry" ensuring we know which videos are processed.

*   **`gmm.pickle` (Python Pickle)**
    *   **Purpose**: Stores the **Gaussian Mixture Model (GMM)**.
    *   **Details**: This is a serialized Python object containing the "visual vocabulary" (means, covariances, weights) learned from clustering features. It translates raw image features into the global Fisher Vector language. **Crucial for both indexing and searching.**

*   **`index.npy` (NumPy Array)**
    *   **Purpose**: The **Master Index**.
    *   **Details**: A binary file storing a Python dictionary.
    *   **Key**: Video/Frame Name (string).
    *   **Value**: Fisher Vector (Floating point array).
    *   **Why `.npy`?**: It is highly optimized for loading and saving large numerical arrays in Python, much faster than text or JSON for this data type.

*   **`.npy` (in `features/`)**
    *   **Purpose**: Intermediate storage for extracted features.
    *   **Details**: Instead of re-computing complex SIFT features (which is slow) every time we want to index, we save them here. If the GMM model changes, we can re-create the index quickly using these files without re-processing the images.

*   **`.pyc` / `__pycache__`**
    *   **Note**: These are compiled Python bytecode files. They are automatically generated to verify faster imports and can be ignored/deleted safely. (Already cleaned up).
